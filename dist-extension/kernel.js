var V=Object.defineProperty;var Y=(t,n,c)=>n in t?V(t,n,{enumerable:!0,configurable:!0,writable:!0,value:c}):t[n]=c;var A=(t,n,c)=>Y(t,typeof n!="symbol"?n+"":n,c);import{k as C,g as B,a as $,e as S,s as v,l as X,b as G,i as F,c as J,d as W,n as j,D as q,f as N,h as K,j as z,w as Q,u as Z,m as ee,o as te}from"./extension/popup/index.js";var x;const b=((x=import.meta)==null?void 0:x.env)??{};function R(t,n,c,i){const f=Number(b==null?void 0:b[t]);return Number.isFinite(f)?Math.min(i,Math.max(c,Math.floor(f))):n}const ne=R("VITE_EXT_TX_FEE_SAFETY_BPS",11500,1e4,3e4),U=BigInt(R("VITE_EXT_TX_FEE_MIN_SOMPI",1e3,1,1e9)),D=BigInt(R("VITE_EXT_TX_FEE_MAX_SOMPI",2e8,1e3,5e9));function P(t){const n=(t*BigInt(ne)+9999n)/10000n;return n<U?U:n>D?D:n}const k="kaspa:qpv7fcvdlz6th4hqjtm9qkkms2dw0raem963x3hm8glu3kjgj7922vy69hv85",ae=30,M=100000n,L=100000000n;function H(t){const n=t*BigInt(ae)/10000n;return n<M?M:n>L?L:n}const oe=X;async function re(t,n,c,i){const f=C(c);if(f<=0n)throw new Error("AMOUNT_TOO_SMALL");const m=H(f),p=f+(m??0n),g=m?3:2,e=await B(t),a=await $(t,i),s=P(await S(1,g,i)),{selected:l,total:o}=v(a.utxos,p,s,e),d=P(await S(l.length,g,i));let u=l,r=o;if(o<p+d){const h=v(a.utxos,p,d,e);u=h.selected,r=h.total}const w=r-p-d;if(w<0n)throw new Error("INSUFFICIENT_FUNDS");const E=[{address:n,amount:f}];m&&k&&E.push({address:k,amount:m});const I=w>0n?{address:t,amount:w}:null;return{id:crypto.randomUUID(),state:"BUILDING",fromAddress:t,network:i,inputs:u,outputs:E,changeOutput:I,fee:d,platformFee:m??void 0,builtAt:Date.now()}}async function se(t){const n=await oe(),c=n.UtxoEntry,i=t.inputs.map(a=>{const s={address:a.address,outpoint:{transactionId:a.txId,index:a.outputIndex},amount:a.amount,scriptPublicKey:{version:a.scriptVersion,scriptPublicKey:a.scriptPublicKey},blockDaaScore:a.blockDaaScore,isCoinbase:a.isCoinbase};if(c)try{return new c(s)}catch{return s}return s}),f=t.outputs.map(a=>({address:a.address,amount:a.amount}));t.opReturnHex&&f.push({value:0n,scriptPublicKey:{version:0,scriptPublicKey:`6a${t.opReturnHex}`}});const m={entries:i,outputs:f,changeAddress:t.fromAddress,priorityFee:{sompi:t.fee},networkId:t.network},p=n.Generator;if(!p)throw new Error("WASM_GENERATOR_UNAVAILABLE: kaspa-wasm Generator class not found. Ensure kaspa-wasm â‰¥ 0.13.0 is installed.");const e=new p(m).next();if(!e)throw new Error("GENERATOR_EMPTY: Generator produced no transaction. Check UTXO availability.");return e}async function ie(t,n,c,i={}){if(!n.length)throw new Error("BATCH_EMPTY: at least one recipient required");const f=n.map(h=>({address:h.address,amount:C(h.amountKas)})),m=f.reduce((h,y)=>h+y.amount,0n);if(m<=0n)throw new Error("AMOUNT_TOO_SMALL");const p=H(m),g=m+(p??0n),e=f.length+1+(p?1:0)+(i.opReturnHex?1:0),a=await B(t),s=await $(t,c),l=P(await S(1,e,c)),{selected:o,total:d}=v(s.utxos,g,l,a),u=P(await S(o.length,e,c));let r=o,w=d;if(w<g+u){const h=v(s.utxos,g,u,a);r=h.selected,w=h.total}const E=w-g-u;if(E<0n)throw new Error("INSUFFICIENT_FUNDS");const I=[...f];p&&k&&I.push({address:k,amount:p});const _=E>0n?{address:t,amount:E}:null;return{id:crypto.randomUUID(),state:"BUILDING",fromAddress:t,network:c,inputs:r,outputs:I,changeOutput:_,fee:u,platformFee:p??void 0,builtAt:Date.now(),agentJobId:i.agentJobId,opReturnHex:i.opReturnHex}}const ce={mainnet:"kaspa:","testnet-10":"kaspatest:","testnet-11":"kaspatest:","testnet-12":"kaspatest:"};async function de(t){var e,a;const n=[];let c;try{const s=t.inputs.filter(o=>(o.scriptClass??"standard")==="covenant");s.length>0&&n.push(`COVENANT_INPUT_UNSUPPORTED: ${s.length} covenant UTXO(s) require covenant-aware spend logic`),c=await G(t.fromAddress,t.network);const l=new Set(c.utxos.map(o=>`${o.txId}:${o.outputIndex}`));for(const o of t.inputs){const d=`${o.txId}:${o.outputIndex}`;l.has(d)||n.push(`UTXO_SPENT: input ${d} no longer available`)}}catch{n.push("UTXO_FETCH_FAILED: could not verify input availability")}let i;try{i=await S(t.inputs.length,t.outputs.length+(t.changeOutput?1:0),t.network),t.fee<i&&n.push(`FEE_TOO_LOW: estimated ${t.fee.toString()} sompi, network requires ${i.toString()} sompi`)}catch{i=t.fee}const f=t.inputs.reduce((s,l)=>s+l.amount,0n),m=t.outputs.reduce((s,l)=>s+l.amount,0n),p=((e=t.changeOutput)==null?void 0:e.amount)??0n;f!==m+p+t.fee&&n.push(`BALANCE_MISMATCH: inputs=${f} != outputs=${m} + change=${p} + fee=${t.fee}`);for(const s of t.outputs)F(s.address)||n.push(`INVALID_ADDRESS: "${s.address}" is not a valid Kaspa address`);t.changeOutput&&!F(t.changeOutput.address)&&n.push(`INVALID_CHANGE_ADDRESS: "${t.changeOutput.address}"`);const g=ce[t.network];if(g){for(const s of t.outputs)s.address.toLowerCase().startsWith(g)||n.push(`NETWORK_MISMATCH: output address "${s.address}" does not match network "${t.network}"`);t.changeOutput&&!t.changeOutput.address.toLowerCase().startsWith(g)&&n.push(`NETWORK_MISMATCH: change address "${t.changeOutput.address}" does not match network "${t.network}"`)}return{valid:n.length===0,estimatedFee:i??t.fee,changeAmount:((a=t.changeOutput)==null?void 0:a.amount)??0n,errors:n}}const ue=X;async function le(t){const n=J();if(!n||!n.mnemonic)throw new Error("WALLET_LOCKED");const c=await ue(),{Mnemonic:i,XPrv:f,XPrivateKey:m}=c;let p=null;const g=c.PrivateKey;try{const e=W(n.address);if(e&&g)p=new g(e);else{const o=j(n.derivation??q),u=new i(n.mnemonic).toSeed(n.mnemonicPassphrase||void 0),r=new f(u);let w=r;try{w=r.derivePath(o.path)}catch(y){if(o.path.startsWith("m/"))w=r.derivePath(o.path.slice(2));else throw y}const E=w.intoString("kprv"),I=new m(E,!1,BigInt(o.account)),_=o.chain===1?I.changeKey(o.index):I.receiveKey(o.index),h=_.toKeypair();if(p=h.privateKey??(typeof h.toPrivateKey=="function"?h.toPrivateKey():null),p){if(g){const y=typeof p.toString=="function"?p.toString("hex"):null;y&&N(n.address,y)}}else{const y=typeof _.toString=="function"?_.toString("hex"):null;g&&y&&(p=new g(y),N(n.address,y))}if(!p)throw new Error("PRIVKEY_UNAVAILABLE: Could not extract PrivateKey from keypair. Verify kaspa-wasm version compatibility.")}const a=await se(t);await a.sign([p]);let s;typeof a.serializeToObject=="function"?s=JSON.stringify({transaction:a.serializeToObject()}):typeof a.toJSON=="function"?s=a.toJSON():s=JSON.stringify({transaction:a});const l=a.id;return{...t,state:"SIGNED",signedTxPayload:s,txId:l,signedAt:Date.now()}}catch(e){const a=e instanceof Error?e.message:String(e);throw new Error(`SIGN_FAILED: ${a}`)}finally{p=null}}class T extends Error{constructor(c,i,f=null,m=[]){super(i);A(this,"stage");A(this,"tx");A(this,"details");this.name="DeterministicExecutionError",this.stage=c,this.tx=f,this.details=m}}const pe={buildTransaction:re,buildBatchTransaction:ie,dryRunValidate:de,signTransaction:le,broadcastTransaction:te,addPendingTx:ee,updatePendingTx:Z,waitForKaspaConfirmation:Q,appendExecutionTelemetryEvent:z};function fe(t={}){const n={...pe,...t},c=async(e,a,s)=>{e&&await e({stage:a,tx:s})},i=async(e,a,s,l,o,d=null)=>{if(e)try{await n.appendExecutionTelemetryEvent({runId:e.runId||K(e.channel),channel:e.channel,stage:a,status:s,network:l,tx:o,error:d,context:e.context})}catch{}},f=e=>e?typeof e=="function"?{onUpdate:e}:e:{},m=async(e,a)=>{const s=f(a),l=s.telemetry?{...s.telemetry,runId:s.telemetry.runId||K(s.telemetry.channel)}:void 0;if(!e.recipients||e.recipients.length===0)throw await i(l,"build","failed",e.network,null,"INTENT_EMPTY: at least one recipient is required."),new T("build","INTENT_EMPTY: at least one recipient is required.");let o;try{if(e.recipients.length===1){const[r]=e.recipients;o=await n.buildTransaction(e.fromAddress,r.address,r.amountKas,e.network),(e.agentJobId||e.opReturnHex)&&(o={...o,agentJobId:e.agentJobId,opReturnHex:e.opReturnHex})}else o=await n.buildBatchTransaction(e.fromAddress,e.recipients,e.network,{agentJobId:e.agentJobId,opReturnHex:e.opReturnHex});await n.addPendingTx(o),await c(s.onUpdate,"build",o),await i(l,"build","ok",e.network,o,null)}catch(r){const w=r instanceof Error?r.message:String(r);throw await i(l,"build","failed",e.network,null,w),new T("build",w,null)}let d;try{d=await n.dryRunValidate(o)}catch(r){const w=r instanceof Error?r.message:String(r);throw await i(l,"validate","failed",e.network,o,w),new T("validate",w,o)}if(!d.valid){const r={...o,state:"DRY_RUN_FAIL",error:d.errors.join("; ")};throw await n.updatePendingTx(r),await i(l,"validate","failed",e.network,r,`KERNEL_DRY_RUN_FAILED: ${d.errors.join("; ")}`),new T("validate",`KERNEL_DRY_RUN_FAILED: ${d.errors.join("; ")}`,r,d.errors)}const u={...o,state:"DRY_RUN_OK",fee:d.estimatedFee};return await n.updatePendingTx(u),await c(s.onUpdate,"validate",u),await i(l,"validate","ok",e.network,u,null),u},p=async(e,a={})=>{const s=a.awaitConfirmation!==!1,l=a.telemetry?{...a.telemetry,runId:a.telemetry.runId||K(a.telemetry.channel)}:void 0;let o;try{o=await n.signTransaction(e),await n.updatePendingTx(o),await c(a.onUpdate,"sign",o),await i(l,"sign","ok",e.network,o,null)}catch(u){const r=u instanceof Error?u.message:String(u);throw await i(l,"sign","failed",e.network,e,r),new T("sign",r,e)}let d;try{d=await n.broadcastTransaction(o),await n.updatePendingTx(d),await c(a.onUpdate,"broadcast",d),await i(l,"broadcast","ok",e.network,d,null)}catch(u){const r=u instanceof Error?u.message:String(u);throw await i(l,"broadcast","failed",e.network,o,r),new T("broadcast",r,o)}if(!s)return await i(l,"reconcile","ok",e.network,d,null),d;try{let u=0;const r=await n.waitForKaspaConfirmation(d,{timeoutMs:a.confirmTimeoutMs,pollIntervalMs:a.confirmPollIntervalMs,onProbe:async w=>{u+=1;const E={...d,receiptCheckedAt:w.checkedAt,receiptProbeAttempts:u,receiptSourceBackend:w.backend.source,receiptSourceReason:w.backend.reason,receiptSourceEndpoint:w.backend.activeEndpoint,acceptingBlockHash:w.acceptingBlockHash};await n.updatePendingTx(E),await c(a.onUpdate,"reconcile",E)}});if(await n.updatePendingTx(r),await c(a.onUpdate,"reconcile",r),r.state==="FAILED")throw await i(l,"reconcile","failed",e.network,r,r.error||"Receipt reconciliation failed."),new T("reconcile",r.error||"Receipt reconciliation failed.",r);return await i(l,"reconcile","ok",e.network,r,null),r}catch(u){if(u instanceof T)throw u;const r=u instanceof Error?u.message:String(u);throw await i(l,"reconcile","failed",e.network,d,r),new T("reconcile",r,d)}};return{buildAndValidateKaspaIntent:m,signBroadcastAndReconcileKaspaTx:p,executeKaspaIntent:async(e,a={})=>{const s=await m(e,{onUpdate:a.onUpdate,telemetry:a.telemetry});return p(s,a)}}}const O=fe(),ge=O.buildAndValidateKaspaIntent,he=O.signBroadcastAndReconcileKaspaTx,Ee=O.executeKaspaIntent;export{T as DeterministicExecutionError,ge as buildAndValidateKaspaIntent,fe as createDeterministicExecutionKernel,Ee as executeKaspaIntent,he as signBroadcastAndReconcileKaspaTx};
